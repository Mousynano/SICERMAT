#include <Wire.h>
#include <WiFi.h>

#include "lib/http.h"
#include "lib/websocket.h"
#include "lib/imu.h"
#include "lib/heart.h"
#include "lib/jump.h"
#include "lib/pushup.h"
#include "lib/punch.h"

// Constants
#define WIFI_SSID "test"
#define WIFI_PASSWORD "12345678"

// Global Variables
// AsyncEventSource events("/events");

// int punchCount = 0;
// float maxPunchPower = 0;
// float avgPunchPower = 0;
// float totalPunchPower = 0;
// float lastRetractionTime = 0;
// float avgRetractionTime = 0;
// float totalRetractionTime = 0;

float jumpHeight = 0;

float heartRate = 0;
float spo2 = 0;

uint32_t LoopTimer;
uint32_t lastWebSocketReconnectAttempt = 0;

int repeatCount = 0;

void terminateWithError(const String& errorMessage) {

  // Print error message
  Serial.println("\n!!! SENSOR ERROR !!!");
  Serial.println(errorMessage);
  Serial.println("Program terminated due to sensor malfunction.");

  // Optional: Perform any cleanup or safety actions
  WiFi.disconnect(true);
  for(;;){
      delay(10000);
  };
}


// void sendSensorData() {
//   StaticJsonDocument<200> acc;
//   acc["type"] = "accelerometer";
//   acc["accX"] = accX;
//   acc["accY"] = accY;
//   acc["accZ"] = accZ;

//   String accJson;
//   serializeJson(acc, accJson);
//   events.send(accJson.c_str(), "sensorData", millis());

//   StaticJsonDocument<200> gyro;
//   gyro["type"] = "gyroscope";
//   gyro["gyroX"] = gyroX * M_PI / 180.0;
//   gyro["gyroY"] = gyroY * M_PI / 180.0;
//   gyro["gyroZ"] = gyroZ * M_PI / 180.0;

//   String gyroJson;
//   serializeJson(gyro, gyroJson);
//   events.send(gyroJson.c_str(), "sensorData", millis());
// }

void connectToWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
      delay(1000);
      Serial.print(".");
  }
  Serial.println("\nWiFi connected!");
  Serial.print("ESP32 IP Address: ");
  Serial.println(WiFi.localIP());
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Connect to WiFi
  connectToWiFi();

  // Inisialisasi mDNS
  if (!MDNS.begin(hostname)) {
      Serial.println("Error setting up mDNS!");
  } else {
      Serial.printf("mDNS responder started: http://%s.local\n", hostname);
  }
  
  registerRoutes(server);

  ws.onEvent(onWebSocketEvent);
  server.addHandler(&events);
  server.begin();

  // Initialize Sensors
  sensorInit(mpu);

  // Calibrate Sensors
  calibrateSensors(mpu);

  // xTaskCreatePinnedToCore(sendDataTask, "SendDataTask", 4096, NULL, 1, NULL, 0);
  // xTaskCreatePinnedToCore(resetQueueTask, "ResetQueueTask", 2048, NULL, 1, NULL, 1);
  // xTaskCreatePinnedToCore(readSensorTask, "ReadSensorTask", 4096, NULL, 1, NULL, 0);

  LoopTimer = micros();
}

void loop() {
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    connectToWiFi();
  }

  // Read sensor data
  sensorSignals(mpu, accX, accY, accZ, gyroX, gyroY, gyroZ, true);

  // Create current reading
  SensorReading currentReading = {accX, accY, accZ, gyroX, gyroY, gyroZ};

  // Check sensor health
  if (!isSensorHealthy(currentReading, previousReading)) {
    repeatCount++;
  } else {
    repeatCount = 0;
  }

  if (repeatCount >= MAX_REPEATED_READINGS) {
    terminateWithError("Data sensornya ngestuck, coba cek wiring sama wiringnya dulu!");
  }

  previousReading = currentReading;

  // Get sport analysis
  PunchMetrics punchMetrics = analyzePunch(accX, accY, accZ);
  if (punchMetrics.valid){
    String punchData = getPunchMetrics(punchPower, retractionTime);
  }

  // JumpMetrics jumpMetrics = analyzeJump(accX, accY, accZ);
  // if (jumpMetrics.valid){
  //   String jumpData = getJumpMetrics(jumpHeight);
  // }

  // PushUpMetrics pushUpMetrics = analyzePushUp(accX, accY, accZ);
  // if (pushUpMetrics.valid){
  //   String pushUpData = getPushUpMetrics();
  // }

  for (auto& entry : clients) {
    ClientData& clientData = entry.second;
    sendJsonToClient(clientData, entry.first, punchData, "punch");
  //   sendJsonToClient(clientData, entry.first, jumpData, "jump");
  //   sendJsonToClient(clientData, entry.first, pushUpData, "pushUp");
  }

  // Send sensor data via WebSocket
  // sendSensorData();

  // Maintain loop timing
  while (millis() - LoopTimer < 100);
  LoopTimer = millis();
}